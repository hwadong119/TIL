## 크루스칼 알고리즘

알고리즘 중에는 여러가지 객체들 사이에 짝을 이루는 관계를 모델링 하기 위해서 사용되는 <b>그래프 알고리즘</b>이라는 것이 있다.

이 그래프 알고리즘은 크게 Vertex라고 불리는 정점(Node)과 Edge라 불리는 간선들의 조합으로 이루어져있다.

이때 방향이 없는 그래프에서 모든 노드를 포함하면서, 순환되는 경로를 제거한 형태를 스패닝 트리(Spanning Tree)라고 한다.

이 스패닝 트리에서 가중치의 합을 최소로 만드는 스패닝 트리를 <b>최소 스패닝 트리 (Minimal Spanning Tree)</b>라고 한다.

이 최소 스패닝 트리(MST)를 만들기 위한 방법으로 <b>크루스칼 알고리즘</b>을 사용한다.

## 크루스칼 알고리즘 동작 원리

1. 모든 간선들의 가중치를 오름차순으로 정렬한다.
2. 가중치가 가장 작은 간선을 선택한다.
3. 2에서 선택한 간선이 연결하려는 2개의 노드가 아직 서로 연결되지 않은 상채라면, 2개의 노드를 서로 연결한다.
4. 위의 과정을 반복한다. <br><br>


![img](./20240202_크루스칼%20알고리즘%20img/크루스칼알고리즘그래프.png)

위의 그래프는 방향을 가지고 있지 않은 가중치가 존재하는 그래프이다.

1. 모든 간선들의 가중치들을 오름차순으로 정렬한다.

    B-C : 1 <br>
    A-B : 3 <br>
    D-E : 3 <br>
    B-D : 4 <br>
    C-E : 4 <br>
    A-D : 5 <br>
    A-E : 7 <br>
    C-D : 8 <br>

2. 위의 가중치값들 중 가장 작은 값을 선택한다.
3. 두 노드가 연결되어 있지 않다면 연결한다. <br><br>
       
![img](./20240202_크루스칼%20알고리즘%20img/1.png)

처음엔 간선들이 모두 끊어진 상태라고 가정하고 생각

B-C를 연결하는 1의 가중치가 가장 작은 값이다. 
모든 간선들이 끊어져 있는 상태이고, B-C 또한 연결되어 있지 않기 때문에 연결을 하고, B-C가 연결되었다고 표시한다. <br><br>

![img](./20240202_크루스칼%20알고리즘%20img/2.png)

그다음은 A-B를 연결하는 3의 가중치가 작은 값인데 아직 A-B는 연결돼 있지 않기 때문에 연결해준다.

이후 D-E를 연결하는 간선도 연결, B-D를 연결하는 간선도 연결해준다.

이 이후에 진행될 가중치가 4인 C-E를 연결하는 간선을 연결해 줄 수 있지만 연결이 돼 있다면 연결을 또 해주면 안 된다. 싸이클이 발생해버리기 때문이다.

C와 E는 C-B-D-E 루트를 통해 이미 연결되어 있는 노드이기 때문에 연결을 하면 안 된다.

A-E, C-D 간선도 이미 다 연결되어 있기 때문에 더 이상 연결을 하지 않고 끝내 버린다. 즉 위의 그림이 크루스칼 알고리즘으로 구현한 MST가 되는 것.

## 크루스칼 알고리즘 실제 코드로 구현하기

먼저 각 간선들의 가중치를 오츰차순으로 정렬해주는 과정이 필요

정렬해 놓은 가중치 값들 중에서 가장 작은 가중치를 갖는 간선이 연결하는 두 노드가 연결되어 있는지 확인을 해주는 과정이 필요

이 과정에서 많이 사용되는 방식이 union-find 방식이다.

union은 합친다라는 의미를 가지고 있다.

즉 두 노드가 연결되어 있지 않으면 두 노드를 합쳐라라는 의미이다.

이를 위해 Parent[]라는 1차원 배열을 사용한다.

이 배열의 역할은 부모가 같은지를 판단해주는 배열이다.

서로 다른 두 노드가 같은 부모를 가지고 있다면 서로 연결이 돼 있음을 뜻하고 서로 다른 부모를 가지고 있다면 서로 연결되어 있지 않음을 뜻한다.

이 배열의 초기값은 자기자신이 된다. 처음에는 모든 노드가 서로 연결되어 있지 않은 상태로 시작해야하므로, 예를 들어 1~5번까지의 노드가 있다면 Parent[1]=1, Parent[2]=2, Parent[3]=3, Parent[4]=4, Parent[5]=5 이런식으로 초기값을 가지게 된다.

find는 찾는다는 의미를 가지고 있다.

여기서 찾는다는 것은 부모를 찾는다는 것을 의미한다. 위에서 부모가 같다면 서로 연결되어 있는 정점이라는 것을 의미한다고 했다. 서로 다른 두 노드의 부모를 찾아 봤을 때, 그 두 개의 노드가 서로 같다면 더이상 연결할 필요가 없고, 서로 다르다면 연결을 할 수 있다.


